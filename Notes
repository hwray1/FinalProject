
class individual:
    """ """
    def __init__(self,phenotype):
        """ """
        self.phenotype = phenotype


class population:
    """ """
    def _init_(self,popSize,phenotype):
        """ """
        self.popSize = popSize
        indList = []
        
        for i in range(popSize):
            self.indList.append(individual(phenotype))
        
    def addMember(self, joiner):
        """ """
        self.indList.append(joiner)
        
    def removeMember(self, leaver):
        """ """
        self.indList.remove(leaver)


class landscape:
	""" """
	def _init_(self,numIndividuals,phenoList):
        """ """
        self.phenoList = phenoList
        self.numPopulations = len(phenoList)

        self.popList = []
        for i in phenoList:
        	self.popList.append(population(numIndividuals,i))

        self.moveMatrix = []
        self.createMatrix(self.numPopulations)

    def createMatrix(self,numPopulations):
    	""" """
    	for i in range(numPopulations):
    		col = []
    		for x in range(numPopulations):
    			col.append(random.randrange(100))

    		self.moveMatrix.append(col)


    def move(self):
    	""" """
    	moveList = []

	for popPosition, currentPop in enumerate(self.popList):
	
		for ind in currentPop.indList:
			choice = random.choice(self.popList, self. moveMatrix[popPosition])
			targetPop = choice[0]

			if targetPop != currentPop:
				moveList.append((ind, currentPop, targetPop))

	for i in moveList:
		currentIndividual = i[0]
		currentPopMove = i[1]
		targetPopMove = i[2]

		currentPopMove.removeMember(currentIndividual)

		targetPopMove.addMember(currentIndividual)




graph populations
	xList = range(steps)
	yList = number of individuals in each population
		each population is separate list- graph as separate lines

graph trajectories for phenotype
	xList = range(steps)
	yList = phenotype frequency for each population
		each population is separate list- graph as separate lines
		each phenotype is a subplot